\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{fancyhdr, amsmath, amssymb, comment, caption, placeins, subfigure,
    fixltx2e, changepage, listings, courier, soul, hyperref, geometry,
    enumerate, listings, enumitem}


\author{\Large{Magnus N\o rskov Stavngaard} \\
		\texttt{magnus@stavngaard.dk}
		\\\\
		\Large{Mark Jan Jacobi} \\
        \texttt{mark@jacobi.pm}
		 \\\\
		\Large{Mads Ynddal} \\
		\texttt{mynddal@me.com}
}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  keywordstyle=\bfseries\color{green!40!black},
  morekeywords={size_t,node,heap},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\lstset{
basicstyle=\footnotesize,
language=C,
numbers=none}

\title{
    \vspace{3cm}
    \Huge{OSM} \\
    \Large{G1}
}

\pagestyle{fancy}
\lhead{\small{Magnus S. Mark J. Mads Y.}}
\chead{\date{\today}}
\rhead{University of Copenhagen}
% \lfoot{}
% \cfoot{}
% \rfoot{}

% Change indent length of paragraph not after a header.
\setlength{\parindent}{0cm}

% Remove page numbering in the beginning
\pagenumbering{gobble}

\begin{document}
    %% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
    %% `natbio-farve` to use SCIENCE's new colors and logo.
    \AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]
        {include/ku-farve}}}
    \AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]
        {include/ku-farve}}}

    %% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
    \AddToShipoutPicture*{\put(0,0){\includegraphics*{include/ku-en}}}

    \clearpage
    \maketitle
    \thispagestyle{empty}

    \newpage

    %\tableofcontents

    %\newpage

    \pagenumbering{arabic} % Arabic page numbers (and reset to 1)

\section*{Task 1 - A priority queue}
\subsection*{Function desciption and assumtions}
\begin{lstlisting}[style=customc]
typedef struct{
  void* thing;
  int priority;
}node;
\end{lstlisting}

\textit{Description}\\
A node containing elements needed for the priority queue. The heap will be build
upon this type. thing contains a pointer to the element queued, and priority
contains an integer. The higher value, the higher priority.\\
\textit{Assumptions}\\
We assumed that the higher priority, the higher the value of int priority\\


\begin{lstlisting}[style=customc]
typedef struct{
  node* root;
  size_t size;
  size_t alloc_size;
}heap;
\end{lstlisting}
\textit{Description}\\
The heap type. Containing an array of node pointers, and a size value, and an size value for the allocated space.\\
\textit{Assumptions}\\
We assumed that root is an array.\\



\begin{lstlisting}[style=customc]
void heap_initialize(heap*);\end{lstlisting}
\textit{Description}\\
Setting up the node, memory assigning with malloc for one node element, and setting
the size variable of the heap type to 0.\\







\begin{lstlisting}[style=customc]
void heap_clear(heap*); \end{lstlisting}
\textit{Description}\\
Freeing up the assigned memory, and resetting the heap object by calling initialize again.\\




 \begin{lstlisting}[style=customc]
size_t heap_size(heap*);\end{lstlisting}

\textit{Description}\\
Returning the amount of elements in the heap. (stored under size in the heap type).\\




 \begin{lstlisting}[style=customc]
void* heap_top(heap*);\end{lstlisting}

\textit{Description}\\
Returns the pointer for the thing in the highest priority node.
\textit{Assumptions}\\
Since this function had a void* type instead of a node*, we assumed that only the void* thing was wanted for return, and not the whole node element. Since the heap structure is maximized, the return will always be the first element of the root array.\\


\begin{lstlisting}[style=customc]
void heap_insert(heap*,void*,int); \end{lstlisting}
\textit{Description}\\
Inserts an element into the heap. The function arguments is an void pointer for the thing in the node type, and an intenger for the priority.\\



\begin{lstlisting}[style=customc]
void* heap_pop(heap*);\end{lstlisting}
\textit{Description}\\
Returns the first element in the heap, and max heapifys them.\\
\textit{Assumptions}\\
Again, we assume that the returned pointer is not the node element, but the pointer for the thing in the node type.\\

\subsection{Running time}
For most of the functions, the running time is constant, in these functions, we do not iterate over the elements, or in some way make the code dependent of the size of the heap. therefore it is constant. We also assume that malloc space allocation is not time dependent of the size allocated.
\\
The functions of interest is heap\_insert and heap\_pop. these have $log(n)$ running times, since we need to maximize the heap, when we add or subtract elements.
\\ \\
heap\_insert uses to bottom to top heapyfi


\section*{Task 2 - syscall read/write}

syscall\_read og syscall\_write blev skrevet med udgangspunkt i init\_startup\_fallback fra init/main.c. Implementeringen understøtter at læse fra og skrive til STDIN og STDOUT, men burde nemt kunne udvides ved at bruge fhandle argumentet.

I syscall.h er funktionsnumrene allerede definreret for read og write.
\begin{lstlisting}[style=customc]
#define SYSCALL\_READ 0x204
#define SYSCALL\_WRITE 0x205
\end{lstlisting}

Så derfor kan man gå direkte til at tilføje en case for hver af dem i syscall.c

\begin{lstlisting}[style=customc]
switch (user_context->cpu_regs[MIPS_REGISTER_A0]) {
    case SYSCALL_HALT:
        halt_kernel();
        break;
    case SYSCALL_READ:
        user_context->cpu_regs[MIPS_REGISTER_V0] =
        syscall_read(
            (int) user_context->cpu_regs[MIPS_REGISTER_A1],
            (void *) user_context->cpu_regs[MIPS_REGISTER_A2],
            (int) user_context->cpu_regs[MIPS_REGISTER_A3]
        );

        break;
    case SYSCALL_WRITE:
        user_context->cpu_regs[MIPS_REGISTER_V0] =
        syscall_write(
            (int) user_context->cpu_regs[MIPS_REGISTER_A1],
            (void const *) user_context->cpu_regs[MIPS_REGISTER_A2],
            (int) user_context->cpu_regs[MIPS_REGISTER_A3]
        );

        break;
    default:
        KERNEL_PANIC("Unhandled system call\n");
}
\end{lstlisting}

De to cases kalder funktioner i filen IO.c som klarer det hele. I syscall.c
sørges blot for at sende argumenterne videre og assigne resultatet til $v0$
registeret.

I IO.c initialiserer syscall\_read ved kun at acceptere STDIN (for simplificering)
og opretter en device handler for TTY, som vi kan bruge til at få en GCD. Denne
Generic Character Device kan bruges til at skrive til, og læse fra, TTY. Nedenfor
er syscall\_read vist med \emph{gcd->read()} til sidst. syscall\_write er magen til,
blot med \emph{gcd->write()} til sidst.

\begin{lstlisting}[style=customc]
int syscall_read(int fhandle, void *buffer, int length)
{
    device_t *dev;
    gcd_t *gcd;

    // Vi vil kun bruge STDIN på nuværende tidspunkt
    if (fhandle != FILEHANDLE_STDIN)
        return -1;

    // Opret en device handle til TTY
    dev = device_get(YAMS_TYPECODE_TTY, 0);
    KERNEL_ASSERT(dev != NULL);

    // Opret generic character device ud fra dev
    gcd = (gcd_t *) dev->generic_device;
    KERNEL_ASSERT(gcd != NULL);

    // Skriv til TTY med read metoden
    return gcd->read(gcd, buffer, length);
}
\end{lstlisting}

\end{document}
