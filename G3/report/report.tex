\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{fancyhdr, amsmath, amssymb, comment, caption, placeins, subfigure,
    fixltx2e, changepage, listings, courier, soul, hyperref, geometry,
enumerate, listings, enumitem}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}


\author{\Large{Magnus N\o rskov Stavngaard} \\
    \texttt{magnus@stavngaard.dk}
    \\\\
    \Large{Mark Jan Jacobi} \\
    \texttt{mark@jacobi.pm}
    \\\\
    \Large{Mads Ynddal} \\
    \texttt{mynddal@me.com}
}

\lstdefinestyle{customc} {
    belowcaptionskip=1\baselineskip,
    breaklines=true,
    xleftmargin=\parindent,
    language=C,
    showstringspaces=false,
    keywordstyle=\bfseries\color{green!40!black},
    morekeywords={size_t,node,heap},
    commentstyle=\itshape\color{purple!40!black},
    identifierstyle=\color{blue},
    stringstyle=\color{orange},
}

\lstset{
    basicstyle=\footnotesize,
    language=C,
numbers=none}
\lstset{literate=
    {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
    {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
    {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
    {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
    {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
    {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
    {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
    {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
    {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
    {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
    {€}{{\EUR}}1 {£}{{\pounds}}1
}

\title{
    \vspace{3cm}
    \Huge{OSM} \\
    \Large{G3}
}

\pagestyle{fancy}
\lhead{\small{Magnus S. Mark J. Mads Y.}}
\chead{\date{\today}}
\rhead{University of Copenhagen}
% \lfoot{}
% \cfoot{}
% \rfoot{}

% Change indent length of paragraph not after a header.
\setlength{\parindent}{0cm}

% Remove page numbering in the beginning
\pagenumbering{gobble}

\begin{document}
%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]
{include/ku-farve}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]
{include/ku-farve}}}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\AddToShipoutPicture*{\put(0,0){\includegraphics*{include/ku-en}}}

\clearpage
\maketitle
\thispagestyle{empty}

\newpage

%\tableofcontents

%\newpage

\pagenumbering{arabic} % Arabic page numbers (and reset to 1)

\section{A thread-safe unbounded queue}



\subsection{Function Descriptions}


\begin{lstlisting}[style=customc]
typedef struct node {
    void *item;
    struct node *next;
} node_t;
\end{lstlisting}
\textit{Description} \\
This type includes a void pointer to an item and an pointer to the next element.
 This creates an linked list, where every typedef refers to its next element.
 this structure is only for a linked list, not for a queue.



\begin{lstlisting}[style=customc]
typedef struct queue {
    pthread_mutex_t queue_put_lock;
    pthread_mutex_t queue_get_lock;
    node_t *head;
    node_t *tail;
} queue_t;
\end{lstlisting}
\textit{Description} \\
The queue type contains a pointer to the head and tail of the node\_t linked list. Furthermore, it also 
contains two pthread\_mutex\_t locks. These are used to lock the queue when adding or removing elements
from the linked list. The reason double pointers are used, instead of only the last element of the linked list, is because the function for returning the first element would have to traverse the full linked list.
When using 2 pointers, we do not need to traverse the list, and we don't need both top and bottom element to return the top. 




\begin{lstlisting}[style=customc]
void *queue_get(queue_t *q);
\end{lstlisting}
\textit{Description} \\
Returns the first element of the queue, then sets the queue head element to the next in the list.
Also frees the memory.



\begin{lstlisting}[style=customc]
void queue_put(queue_t *q, void *item);
\end{lstlisting}
\textit{Description} \\
Adds an item to the linked list. Sets the tail pointer to this element, and sets the last node in the linked list to point at the new element as its next.



\begin{lstlisting}[style=customc]
void queue_init(queue_t *q);
\end{lstlisting}
\textit{Description} \\
Creates an empty queue element, with one node element inside. This is done so that getting an element from an empty queue can be handled easier. This way ,we know that a top node must have an next element. if not (NULL) we can return null instead of the init element.

\subsection{Thread locks}
The put and get functions use a mutex thread lock. This is done so multiple threads can't have access to the same element in the linked list.
\subsection{The test}
The test First generates a thousand threads. These threads will put and get the elements instant 

\section{Userland semaphores for Buenos}
\subsection{syscall\_sem\_p}
To \emph{procure} (reserve) a resource, we implemented the \emph{syscall\_sem\_p(handle)} system call. It takes a semaphore handle as argument, that was previously returned by the \emph{syscall\_sem\_open(name, value)} call. The handle is used only internally by the userland semaphores. The kernel semaphore is hidden inside the \emph{struct usr\_sem\_t\_wrapper}.

After checking the argument for runtime errors, the kernel semaphore is retrieved, and the procure function from the kernel is called.

% int syscall_sem_p(usr_sem_t* handle)
% {
%     int index;
%     usr_sem_t_wrapper *handle_wrapper;

%     /* Return error if handle is NULL. */
%     KERNEL_ASSERT(handle != NULL);

%     /* Get the index in the array. */
%     index = *((int *) handle);

%     /* Get the actual handle and procure a resource. */
%     handle_wrapper = &(semaphores[index]);

%     if (handle_wrapper->status == SEM_NONALLOCED) {
%         return SEM_DOES_NOT_EXIST;
%     }

%     semaphore_P(handle_wrapper->kernel_semaphore);

%     return 0;
% }

\subsection{syscall\_sem\_v}
To vacate (release) a resource, we implemented the \emph{syscall\_sem\_v} system call in nearly the same way as \emph{syscall\_sem\_p}. The function takes a handle as argument and retrieves the kernel semaphore. The kernel function \emph{semaphore\_V} is called with the retrieved kernel semaphore as argument.

% int syscall_sem_v(usr_sem_t* handle)
% {
%     int index;
%     usr_sem_t_wrapper *handle_wrapper;

%     /* Return error if handle is NULL. */
%     KERNEL_ASSERT(handle != NULL);

%     /* Get the index in the array. */
%     index = *((int *) handle);

%     /* Get the actual handle and vacate the resource. */
%     handle_wrapper = &(semaphores[index]);

%     if (handle_wrapper->status == SEM_NONALLOCED) {
%         return SEM_DOES_NOT_EXIST;
%     }

%     semaphore_V(handle_wrapper->kernel_semaphore);

%     return 0;
% }

\subsection{syscall\_sem\_destroy}
When a semaphore is no longer needed. It can safely be discarded with the \emph{syscall\_sem\_destroy(handle)} call. The function will prevent simple runtime errors and afterwards check if the semaphore is still in use ie. a function is waiting for a vacate call. To ensure, that the function is not interrupted, all interrupts are disabled, and the function acquires the handle's spinlock. If nothing is using the semaphore, the semaphore is set to \emph{SEM\_NONALLOCED} and is now able to get reallocated in a \emph{syscall\_sem\_open} call.

% /* Removes a semaphore with a given handle, the handle is dereferenced to be an
%  * integer corresponding to an index in the array of semaphores.  This index is
%  * used to find a semaphore and remove it. */
% int syscall_sem_destroy(usr_sem_t* handle)
% {
%     interrupt_status_t intr_status;

%     usr_sem_t_wrapper *handle_wrapper = &semaphores[*((int *)handle)];

%     /* Semaphore doesn't exist. */
%     if (handle_wrapper->status == SEM_NONALLOCED) {
%         return SEM_DOES_NOT_EXIST;
%     }

%     /* Lock when testing if the semaphore is ready to be removed. */
%     intr_status = _interrupt_disable();
%     spinlock_acquire(&handle_wrapper->slock);

%     /* Test if the semaphore is done being used. */
%     if (handle_wrapper->initial_value !=
%         handle_wrapper->kernel_semaphore->value) {

%         /* Release the lock. */
%         spinlock_release(&handle_wrapper->slock);
%         _interrupt_set_state(intr_status);

%         return SEM_IN_USE;
%     }

%     handle_wrapper->status = SEM_NONALLOCED;

%     /* Destroy kernel semaphore. */
%     semaphore_destroy(handle_wrapper->kernel_semaphore);

%     /* Release the lock. */
%     spinlock_release(&handle_wrapper->slock);
%     _interrupt_set_state(intr_status);

%     return SUCCESS;
% }

\end{document}
